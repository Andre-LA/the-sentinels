-- Copyright (c) 2022, AndrÃ© Luiz Alvares and Leonardo Santos
-- SPDX-License-Identifier: CC-BY-NC-SA-4.0

-- Disable GC and use 32-bit numbers by default
## context.rootpragmas.nogc = true
-- ## primtypes.uinteger = primtypes.uint32
-- ## primtypes.integer = primtypes.int32
-- ## primtypes.number = primtypes.float32


require "wasm4"

-- nelua
local math = require 'math'

-- core
local Vec2  = require 'math.vec2'
local Rect  = require 'math.rect'
local units = require 'units'
local game_functions = require 'game_functions'

-- entities
local Player = require 'entities.player'
local Door   = require 'entities.door'
local Switch = require 'entities.switch'
local Enemy  = require 'entities.enemy'
local Obstacle  = require 'entities.obstacle'

-- gui
local dialogue = require 'gui.dialogue'

-- game
local GameState = @record{
  current_level: integer,
  player: Player,
  door: Door,
  switches: [16]Switch, -- TODO: use the least necessary entities possible
  enemies: [16]Enemy,
  obstacles: [64]Obstacle,
}
local GameState.instance: GameState

local function get_intersection_dir(r: Rect, self_center: Vec2): Vec2
  local function get_dir(self_center: number, rc: number): number
    if self_center > rc then return 1
    elseif self_center < rc then return -1
    else return 0
    end
  end
  local rc = r:get_center()

  if r.size.x > r.size.y then -- is horizontal
    return Vec2{ 0, get_dir(self_center.y, rc.y) }
  elseif r.size.x == r.size.y then -- is square
    return Vec2{ get_dir(self_center.x, rc.x), get_dir(self_center.y, rc.y) }
  else
    return Vec2{ get_dir(self_center.x, rc.x), 0 }
  end
end

function GameState.is_intersecting_player(hitbox: Rect): (boolean, Vec2)
  local self = &GameState.instance
  local player_hb = self.player:hitbox()

  if hitbox:is_intersecting(player_hb) then
    local intersection = hitbox:get_intersection(player_hb)
    local dir = get_intersection_dir(intersection, hitbox:get_center())
    return true, dir
  end

  return false
end

function GameState.is_intersecting_obstacle(hitbox: Rect): (boolean, Vec2)
  local self = &GameState.instance
  local dir: Vec2, is_intersecting: boolean

  for i = 0, < #self.obstacles do
    if hitbox:is_intersecting(self.obstacles[i]:hitbox()) then
      is_intersecting = true
      local intersection = hitbox:get_intersection(self.obstacles[i]:hitbox())
      local i_dir = get_intersection_dir(intersection, hitbox:get_center())

      if i_dir.x ~= 0.0 then
        dir.x = i_dir.x
      end
      if i_dir.y ~= 0.0 then
        dir.y = i_dir.y
      end
    end
  end

  return is_intersecting, dir
end

function GameState.is_intersecting_switch(hitbox: Rect): (boolean, Vec2, pointer)
  local self = &GameState.instance
  for i = 0, < #self.switches do
    if not self.switches[i].active then
      continue
    end

    local s_hb = self.switches[i]:hitbox()

    if hitbox:is_intersecting(s_hb) then
      local intersection = hitbox:get_intersection(s_hb)
      local dir = get_intersection_dir(intersection, hitbox:get_center())
      return true, dir, &self.switches[i]
    end
  end

  return false
end

function GameState.is_intersecting_door(hitbox: Rect): boolean
  local self = &GameState.instance
  return hitbox:is_intersecting(self.door:hitbox())
end

function GameState.is_enemy_seeing_player(enemy_center: Vec2, max_distance_sqr: number): (boolean, Vec2)
  local self = &GameState.instance

  local seg2player = self.player.position - enemy_center
  local pl_dist_sqr = seg2player:len_sqr()

  if pl_dist_sqr > max_distance_sqr then
    return false
  else
    for i = 0, < #self.obstacles do
      local o_intersection, o_intersection_dist = self.obstacles[i]:hitbox():is_intersected_by_segment(
        self.player.position, enemy_center
      )

      if o_intersection and o_intersection_dist < pl_dist_sqr then
        return false
      end
    end
  end

  return true, seg2player:normalized()
end

function GameState.get_camera_offset(): Vec2
  local self = &GameState.instance
  return self.player:hitbox():get_center() - Vec2{80,80}
end

function GameState:close_level(player_pos: Vec2)
  self.player.position = player_pos
  self.switches = {}
  self.obstacles = {}
  self.enemies = {}
end

function GameState:open_level(level: integer)
  local function init_obstacle(x: number, y: number, w: number, h: number): Obstacle
    return Obstacle{ rect = { pos = units.coords(x, y), size = units.coords(w, h) } }
  end

  self:close_level()

  ## local function clear_obstacles(...)
    ## for i = 1, select('#', ...) do
      GameState.instance.obstacles[#[select(i, ...)]#] = {}
    ## end
  ## end

  ## local function init_obstacles(obstacles)
    ## for i, v in pairs(obstacles) do
      GameState.instance.obstacles[#[i]#] = init_obstacle(#[ v[1] ]#, #[ v[2] ]#, #[ v[3] ]#, #[ v[4] ]#)
    ## end
  ## end

  ## local switch_templates = {}
  ##[[
  function switch_templates._get_indexes(tbl)
    local indexes = {}
    for i, _ in pairs(tbl) do
      table.insert(indexes, i)
    end
    return indexes
  end
  ]]

  ## function switch_templates.basic_macro(idx, data)
    GameState.instance.switches[ #[idx]# ] = {
      active = true,
      position = units.coords( #[ data.pos[1] ]#, #[ data.pos[2] ]# ),
      action     = function() ##[[ data.action() ]] end,
      undoaction = function() ##[[ data.undoaction() ]] end,
    }
  ## end

  ##[[
  function switch_templates.openclose_obstacle(idx, data)
    local obstacles_to_clear = switch_templates._get_indexes(data.obstacles)
    data.action     = function() clear_obstacles(table.unpack(obstacles_to_clear)) end
    data.undoaction = function() init_obstacles(data.obstacles) end

    switch_templates.basic_macro(idx, data)
  end

  function switch_templates.closeopen_obstacle(idx, data)
    local obstacles_to_clear = switch_templates._get_indexes(data.obstacles)
    data.action     = function() init_obstacles(data.obstacles) end
    data.undoaction = function() clear_obstacles(table.unpack(obstacles_to_clear)) end

    switch_templates.basic_macro(idx, data)
  end
  ]]

  switch level do
  -- === LEVEL 01 === --
  case 1 then
    -- player pos
    self.player.position = units.coords(2, 3)

    -- door pos
    self.door.position = units.coords(12, 3)

    -- obstacles
    self.obstacles = {
      -- left room
      init_obstacle( 0,0 , 15,1),
      init_obstacle( 0,6 , 15,1),
      init_obstacle( 0,1 ,  1,5),
      init_obstacle(14,1 ,  1,5),

      init_obstacle( 7,1 ,  1,5), -- disabled by switch #0
    }

    -- switches
    ##[[
    switch_templates.openclose_obstacle(0, { pos = {5, 3}, obstacles = {
      [4] = {7,1 , 1,5},
    }})
    ]]

    dialogue.show()

  -- === LEVEL 02 === --
  case 2 then
    -- player pos
    self.player.position = units.coords(2, 6)

    -- door pos
    self.door.position = units.coords(26, 4)

    -- obstacles
    self.obstacles = {
      -- left room
      init_obstacle(0,0 , 9,1),
      init_obstacle(0,8 , 9,1),
      init_obstacle(0,0 , 1,8), -- [02]: switch #1

      -- corridor
      init_obstacle(8,1 , 12,1),
      init_obstacle(8,7 , 12,1),

      -- right room
      init_obstacle(19,0 , 10,1),
      init_obstacle(19,8 , 10,1),
      init_obstacle(28,1 ,  1,7),

      -- enemy room
      init_obstacle(-7,-2 , 7, 1),
      init_obstacle(-7,10 , 7, 1),
      init_obstacle(-7,-1 , 1,11),
      init_obstacle( 0,-2 , 1, 2),
      init_obstacle( 0, 9 , 1, 2),

      -- init_obstacle(20,1 , 1,7), -- [13]: switch #2
    }

    -- switches
    ##[[
    switch_templates.openclose_obstacle(0, { pos = {4, 2}, obstacles = {
      [2] = {0,0 , 1,8},
    }})
    switch_templates.closeopen_obstacle(1, { pos = {22, 4}, obstacles = {
      [13] = {20,1 , 1,7},
    }})
    ]]

    -- enemies
    self.enemies[0] = { active = true, position = units.coords(-4, 4) }

  -- === LEVEL 03 === --
  case 3 then
    -- player pos
    self.player.position = units.coords(3, 2)

    -- door pos
    self.door.position = units.coords(23, 10)

    -- obstacles
    self.obstacles = {
      init_obstacle( 0, 1 ,  1, 12), -- left wall
      init_obstacle( 0, 0 , 26,  1), -- up wall
      init_obstacle( 0,13 , 26,  1), -- down wall
      init_obstacle(25, 1 ,  1, 12), -- right wall room
      init_obstacle( 6, 1 ,  1, 10), -- 1st v(ertical) wall

      -- 2nd v wall
      init_obstacle(11, 3 ,  1, 5), -- [05]: switch #1
      init_obstacle( 7, 7 ,  4, 1), -- [06]: switch #0
      init_obstacle(11, 8 ,  1, 5), -- [07]: switch #0
      -- 3rd v wall
      init_obstacle(16, 6 ,  1, 5), -- [08]: switch #2
      init_obstacle(12, 7 ,  4, 1), -- [09]: switch #1
      init_obstacle(16, 1 ,  1, 5), -- [10]: switch #1
      -- 4th v wall
      init_obstacle(21, 3 ,  1, 5), -- [11]: switch #3
      init_obstacle(17, 7 ,  4, 1), -- [12]: switch #2
      init_obstacle(21, 8 ,  1, 5), -- [13]: switch #2
      -- last h wall
      init_obstacle(22, 7 ,  4, 1), -- [14]: switch #3
    }

    -- switches
    ##[[
    switch_templates.openclose_obstacle(0, { pos = {8.5, 10}, obstacles = {
      [6] = { 7,7 , 4,1},
      [7] = {11,8 , 1,5},
    }})
    switch_templates.basic_macro(1, { pos = { 13.5, 3},
      action = function()
        clear_obstacles(9, 10);
        init_obstacles({ [5] = {11,1 , 1,12} })
      end,
      undoaction = function()
        init_obstacles({
          [9] = {12,7 , 4,1},
          [10] = {16,1 , 1,5},
          [5] = {11,3 , 1,5}
        })
      end,
    })
    switch_templates.basic_macro(2, { pos = { 18.5, 10},
      action = function()
        clear_obstacles(12, 13);
        init_obstacles({ [8] = {16,1 , 1,12} })
      end,
      undoaction = function()
        init_obstacles({
          [6] = {17,7 , 4,1},
          [7] = {21,8 , 1,5},
          [8] = {16,6 , 1,5}
         })
      end,
    })
    switch_templates.basic_macro(3, { pos = { 23.5, 3},
      action = function()
        clear_obstacles(14);
        init_obstacles({ [11] = {21,1 , 1,12} })
      end,
      undoaction = function()
        init_obstacles({
          [14] = {22,7 , 4,1},
          [11] = {21,3 , 1,5}
         })
      end,
    })
    ]]

    -- enemies
    self.enemies[0] = { active = true, position = units.coords(  13, 10) }
    self.enemies[1] = { active = true, position = units.coords(  18,  3) }
    self.enemies[2] = { active = true, position = units.coords(22.5, 10) }

    dialogue.show()
  end

  self.current_level = level
end

function GameState.open_next_level()
  local self = &GameState.instance
  self:open_level(self.current_level + 1)
end

function GameState.lost_level()
  local self = &GameState.instance
  self:open_level(self.current_level)
end

-- main
game_functions.lost_level        = GameState.lost_level
game_functions.open_next_level   = GameState.open_next_level
game_functions.get_camera_offset = GameState.get_camera_offset
game_functions.is_intersecting_obstacle = GameState.is_intersecting_obstacle
game_functions.is_intersecting_door     = GameState.is_intersecting_door
game_functions.is_intersecting_switch   = GameState.is_intersecting_switch
game_functions.is_intersecting_player   = GameState.is_intersecting_player
game_functions.is_enemy_seeing_player   = GameState.is_enemy_seeing_player

GameState.instance:open_level(1)

local function update()
  if not dialogue.active then
    GameState.instance.player:update()
    for i = 0, < #GameState.instance.enemies do GameState.instance.enemies[i]:update() end
  else
    dialogue.update()
  end

  GameState.instance.door:paint()
  for i = 0, < #GameState.instance.obstacles do GameState.instance.obstacles[i]:paint() end
  for i = 0, < #GameState.instance.switches do GameState.instance.switches[i]:paint() end
  for i = 0, < #GameState.instance.enemies do GameState.instance.enemies[i]:paint() end

  GameState.instance.player:paint()

  if dialogue.active then
    dialogue.paint()
  end
end

setup_wasm4_callbacks!(update)

