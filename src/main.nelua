-- Copyright (c) 2022, AndrÃ© Luiz Alvares and Leonardo Santos
-- SPDX-License-Identifier: CC-BY-NC-SA-4.0

-- Disable GC and use 32-bit numbers by default
## context.rootpragmas.nogc = true
-- ## primtypes.uinteger = primtypes.uint32
-- ## primtypes.integer = primtypes.int32
-- ## primtypes.number = primtypes.float32


require "wasm4"

-- nelua
local math = require 'math'

-- core
local Vec2 = require 'math.vec2'
local Rect = require 'math.rect'
local units = require 'units'
local game_functions = require 'game_functions'

-- entities
local Player = require 'entities.player'
local Switch = require 'entities.switch'
local Enemy = require 'entities.enemy'

local GameState = @record{
  player: Player,
  switches: [4]Switch,
  enemies: [1]Enemy,
  obstacles: [16]Rect
}
local GameState.instance: GameState
## print('#GameState (%)', GameState.value.size, GameState.value.size / (1024*64))

local function get_intersection_dir(r: Rect, self_center: Vec2): Vec2
  local function get_dir(self_center: number, rc: number): number
    if self_center > rc then return 1
    elseif self_center < rc then return -1
    else return 0
    end
  end
  local rc = r:get_center()

  if r.size.x > r.size.y then -- is horizontal
    return Vec2{ 0, get_dir(self_center.y, rc.y) }
  elseif r.size.x == r.size.y then -- is square
    return Vec2{ get_dir(self_center.x, rc.x), get_dir(self_center.y, rc.y) }
  else
    return Vec2{ get_dir(self_center.x, rc.x), 0 }
  end
end

function GameState.is_intersecting_player(hitbox: Rect): (boolean, Vec2)
  local self = &GameState.instance
  local player_hb = self.player:hitbox()

  if hitbox:is_intersecting(player_hb) then
    local intersection = hitbox:get_intersection(player_hb)
    local dir = get_intersection_dir(intersection, hitbox:get_center())
    return true, dir
  end

  return false
end

function GameState.is_intersecting_obstacle(hitbox: Rect): (boolean, Vec2)
  local self = &GameState.instance
  local dir: Vec2, is_intersecting: boolean

  for i = 0, < #self.obstacles do
    if hitbox:is_intersecting(self.obstacles[i]) then
      is_intersecting = true
      local intersection = hitbox:get_intersection(self.obstacles[i])
      local i_dir = get_intersection_dir(intersection, hitbox:get_center())

      if i_dir.x ~= 0.0 then
        dir.x = i_dir.x
      end
      if i_dir.y ~= 0.0 then
        dir.y = i_dir.y
      end
    end
  end

  return is_intersecting, dir
end

function GameState.is_intersecting_switch(hitbox: Rect): (boolean, Vec2, pointer)
  local self = &GameState.instance
  for i = 0, < #self.switches do
    if not self.switches[i].active then
      continue
    end

    local s_hb = self.switches[i]:hitbox()

    if hitbox:is_intersecting(s_hb) then
      local intersection = hitbox:get_intersection(s_hb)
      local dir = get_intersection_dir(intersection, hitbox:get_center())
      return true, dir, &self.switches[i]
    end
  end

  return false
end

function GameState.is_enemy_seeing_player(enemy_center: Vec2, max_distance_sqr: number): (boolean, Vec2)
  local self = &GameState.instance

  local seg2player = self.player.position - enemy_center
  local pl_dist_sqr = seg2player:len_sqr()

  if pl_dist_sqr > max_distance_sqr then
    return false
  else
    for i = 0, < #self.obstacles do
      local o_intersection, o_intersection_dist = self.obstacles[i]:is_intersected_by_segment(
        self.player.position, enemy_center
      )

      if o_intersection and o_intersection_dist < pl_dist_sqr then
        return false
      end
    end
  end

  return true, seg2player:normalized()
end

function GameState.get_camera_offset(): Vec2
  local self = &GameState.instance
  return self.player:hitbox():get_center() - Vec2{80,80}
end

function GameState:close_level(player_pos: Vec2)
  self.player.position = player_pos
  self.switches = {}
  self.obstacles = {}
  self.enemies = {}
end

function GameState:open_level(level: integer <comptime>)
  local function init_obstacle(x: integer, y: integer, w: integer, h: integer): Rect
    return Rect{ pos  = units.coords(x, y), size = units.coords(w, h) }
  end

  self:close_level()

  -- === LEVEL 01 === --
  ## if level.value == 1 then
    -- player pos
    self.player.position = units.coords(2, 6)

    -- obstacles
    self.obstacles[0] = init_obstacle(0,0 , 4,1)
    self.obstacles[1] = init_obstacle(0,8 , 4,1)
    self.obstacles[2] = init_obstacle(0,0 , 1,8)

    -- switches
    self.switches[0] = { active = true, position = units.coords(2, 2), action = function()
      GameState.instance.obstacles[2] = {}
    end}

    -- enemies
    self.enemies[0] = { active = true, position = units.coords(-4, 4) }
  ## end
end

game_functions.get_camera_offset = GameState.get_camera_offset
game_functions.is_intersecting_obstacle = GameState.is_intersecting_obstacle
game_functions.is_intersecting_switch   = GameState.is_intersecting_switch
game_functions.is_intersecting_player   = GameState.is_intersecting_player
game_functions.is_enemy_seeing_player   = GameState.is_enemy_seeing_player

GameState.instance:open_level(1)

local function update()
  GameState.instance.player:update()
  for i = 0, < #GameState.instance.enemies do GameState.instance.enemies[i]:update() end

  for i = 0, < #GameState.instance.obstacles do GameState.instance.obstacles[i]:paint(GameState.get_camera_offset()) end
  for i = 0, < #GameState.instance.switches do GameState.instance.switches[i]:paint() end
  for i = 0, < #GameState.instance.enemies do GameState.instance.enemies[i]:paint() end

  GameState.instance.player:paint()
end

setup_wasm4_callbacks!(update)

