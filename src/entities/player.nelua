-- nelua
local math = require 'math'
-- core
local Vec2 = require 'math.vec2'
local Rect = require 'math.rect'
local units = require 'units'
local game_functions = require 'game_functions'

-- entities
local Switch = require 'entities.switch'

-- tileset
local tileset = require 'levels.tileset'

-- player
local Player = @record{
  position: Vec2,
  frame_cycle: byte,
  _prevframe_b1_pressed: boolean
}

local function emit_walk_sfx()
  local freq: uint32 <comptime> = 160 | (180 << 16)
  local dur: uint32 <comptime> = 3
  local vol: uint32 <comptime> = 22 | (34 << 8)
  local flags: uint32 <comptime> = TONE_TRIANGLE | TONE_MODE1

  tone(freq, dur, vol, flags)
end

function Player:update_sfx()
  self.frame_cycle = (self.frame_cycle + 1) % 12

  if self.frame_cycle == 0 then
    emit_walk_sfx()
  end
end

function Player:hitbox(): Rect
  return Rect { pos = self.position, size = {units.UNIT, units.UNIT} }
end

function Player:get_center(): Vec2
  return self.position + Vec2{ (units.UNIT//2) , (units.UNIT//2) }
end

function Player:get_paint_bottom(): Vec2
  return self.position - game_functions.get_camera_offset() + Vec2{ (units.UNIT//2) , units.UNIT }
end

function Player:update()
  local is_right_pressed = $GAMEPAD1 & BUTTON_RIGHT ~= 0
  local is_left_pressed  = $GAMEPAD1 & BUTTON_LEFT ~= 0
  local is_up_pressed    = $GAMEPAD1 & BUTTON_UP ~= 0
  local is_down_pressed  = $GAMEPAD1 & BUTTON_DOWN ~= 0

  local is_b1_pressed = $GAMEPAD1 & BUTTON_1 ~= 0
  local is_b1_just_pressed = is_b1_pressed and not self._prevframe_b1_pressed
  self._prevframe_b1_pressed = is_b1_pressed

  local SPEED <comptime> = 8 * units.UNIT * units.DT

  local is_colliding, collision_dir = game_functions.is_intersecting_obstacle(self:hitbox())

  if is_colliding then
    if is_right_pressed and collision_dir.x < 0.0 then is_right_pressed = false end
    if is_left_pressed  and collision_dir.x > 0.0 then is_left_pressed  = false end
    if is_up_pressed    and collision_dir.y > 0.0 then is_up_pressed    = false end
    if is_down_pressed  and collision_dir.y < 0.0 then is_down_pressed  = false end
  end

  local dir: Vec2;

  if is_right_pressed then dir.x =  1 end
  if is_left_pressed  then dir.x = -1 end
  if is_down_pressed  then dir.y =  1 end
  if is_up_pressed    then dir.y = -1 end

  if dir:len_sqr() > 0 then
    dir = dir:normalized()
    self.position = self.position + dir * SPEED
    self:update_sfx()
  end

  if is_b1_just_pressed then
    local is_nearto_switch, _, sw_ptr = game_functions.is_intersecting_switch(self:hitbox())
    if is_nearto_switch then
      local sw_ptr: *Switch = (@pointer(Switch))(sw_ptr)
      sw_ptr:actionate()
    end

    local is_nearto_door, _, sw_ptr = game_functions.is_intersecting_door(self:hitbox())
    if is_nearto_door then
      game_functions.open_next_level()
    end
  end
end

function Player:paint()
  self:hitbox():paint(game_functions.get_camera_offset())

  local pos = self.position - game_functions.get_camera_offset() - Vec2{5, 14}
  tileset.paint_sub(0, 6, 2, 3, math.ifloor(pos.x), math.ifloor(pos.y))
end

return Player
