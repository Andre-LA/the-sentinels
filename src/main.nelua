-- Copyright (c) 2022, AndrÃ© Luiz Alvares and Leonardo Santos
-- SPDX-License-Identifier: CC-BY-NC-SA-4.0

-- Disable GC and use 32-bit numbers by default
## context.rootpragmas.nogc = true
-- ## primtypes.uinteger = primtypes.uint32
-- ## primtypes.integer = primtypes.int32
-- ## primtypes.number = primtypes.float32


require "wasm4"

-- nelua
local math = require 'math'

-- core
local Vec2  = require 'math.vec2'
local Rect  = require 'math.rect'
local units = require 'units'
local game_functions = require 'game_functions'

-- entities
local Player = require 'entities.player'
local Door   = require 'entities.door'
local Switch = require 'entities.switch'
local Enemy  = require 'entities.enemy'

-- game
local GameState = @record{
  current_level: integer,
  player: Player,
  door: Door,
  switches: [4]Switch,
  enemies: [1]Enemy,
  obstacles: [16]Rect
}
local GameState.instance: GameState
## print('#GameState (%)', GameState.value.size, GameState.value.size / (1024*64))

local function get_intersection_dir(r: Rect, self_center: Vec2): Vec2
  local function get_dir(self_center: number, rc: number): number
    if self_center > rc then return 1
    elseif self_center < rc then return -1
    else return 0
    end
  end
  local rc = r:get_center()

  if r.size.x > r.size.y then -- is horizontal
    return Vec2{ 0, get_dir(self_center.y, rc.y) }
  elseif r.size.x == r.size.y then -- is square
    return Vec2{ get_dir(self_center.x, rc.x), get_dir(self_center.y, rc.y) }
  else
    return Vec2{ get_dir(self_center.x, rc.x), 0 }
  end
end

function GameState.is_intersecting_player(hitbox: Rect): (boolean, Vec2)
  local self = &GameState.instance
  local player_hb = self.player:hitbox()

  if hitbox:is_intersecting(player_hb) then
    local intersection = hitbox:get_intersection(player_hb)
    local dir = get_intersection_dir(intersection, hitbox:get_center())
    return true, dir
  end

  return false
end

function GameState.is_intersecting_obstacle(hitbox: Rect): (boolean, Vec2)
  local self = &GameState.instance
  local dir: Vec2, is_intersecting: boolean

  for i = 0, < #self.obstacles do
    if hitbox:is_intersecting(self.obstacles[i]) then
      is_intersecting = true
      local intersection = hitbox:get_intersection(self.obstacles[i])
      local i_dir = get_intersection_dir(intersection, hitbox:get_center())

      if i_dir.x ~= 0.0 then
        dir.x = i_dir.x
      end
      if i_dir.y ~= 0.0 then
        dir.y = i_dir.y
      end
    end
  end

  return is_intersecting, dir
end

function GameState.is_intersecting_switch(hitbox: Rect): (boolean, Vec2, pointer)
  local self = &GameState.instance
  for i = 0, < #self.switches do
    if not self.switches[i].active then
      continue
    end

    local s_hb = self.switches[i]:hitbox()

    if hitbox:is_intersecting(s_hb) then
      local intersection = hitbox:get_intersection(s_hb)
      local dir = get_intersection_dir(intersection, hitbox:get_center())
      return true, dir, &self.switches[i]
    end
  end

  return false
end

function GameState.is_intersecting_door(hitbox: Rect): boolean
  local self = &GameState.instance
  return hitbox:is_intersecting(self.door:hitbox())
end

function GameState.is_enemy_seeing_player(enemy_center: Vec2, max_distance_sqr: number): (boolean, Vec2)
  local self = &GameState.instance

  local seg2player = self.player.position - enemy_center
  local pl_dist_sqr = seg2player:len_sqr()

  if pl_dist_sqr > max_distance_sqr then
    return false
  else
    for i = 0, < #self.obstacles do
      local o_intersection, o_intersection_dist = self.obstacles[i]:is_intersected_by_segment(
        self.player.position, enemy_center
      )

      if o_intersection and o_intersection_dist < pl_dist_sqr then
        return false
      end
    end
  end

  return true, seg2player:normalized()
end

function GameState.get_camera_offset(): Vec2
  local self = &GameState.instance
  return self.player:hitbox():get_center() - Vec2{80,80}
end

function GameState:close_level(player_pos: Vec2)
  self.player.position = player_pos
  self.switches = {}
  self.obstacles = {}
  self.enemies = {}
end

function GameState:open_level(level: integer)
  local function init_obstacle(x: number, y: number, w: number, h: number): Rect
    return Rect{ pos  = units.coords(x, y), size = units.coords(w, h) }
  end

  self:close_level()

  switch level do
  -- === LEVEL 01 === --
  case 1 then
    -- player pos
    self.player.position = units.coords(2, 3)

    -- door pos
    self.door.position = units.coords(12, 3)

    -- obstacles
    self.obstacles = {
      -- left room
      init_obstacle( 0,0 , 15,1),
      init_obstacle( 0,6 , 15,1),
      init_obstacle( 0,1 ,  1,5),
      init_obstacle(14,1 ,  1,5),

      init_obstacle( 7,1 ,  1,5), -- disabled by switch #0
    }

    -- switches
    self.switches = {
      {
        active = true,
        position = units.coords(5, 3),
        action = function() GameState.instance.obstacles[4] = {} end,
        undoaction = function() GameState.instance.obstacles[4] = init_obstacle( 7,1 ,  1,5) end,
      }
    }

  -- === LEVEL 02 === --
  case 2 then
    -- player pos
    self.player.position = units.coords(2, 6)

    -- door pos
    self.door.position = units.coords(26, 4)

    -- obstacles
    self.obstacles = {
      -- left room
      init_obstacle(0,0 , 9,1),
      init_obstacle(0,8 , 9,1),
      init_obstacle(0,0 , 1,8), -- disabled by switch #1

      -- corridor
      init_obstacle(8,1 , 12.75,1),
      init_obstacle(8,7 , 12.75,1),

      -- right room
      init_obstacle(20,0 , 9,1),
      init_obstacle(20,8 , 9,1),
      init_obstacle(28,0 , 1,8),

      -- init_obstacle(20,1 , 1,7), -- enabled by switch #2
    }

    -- switches
    self.switches = {
      {
        active = true,
        position = units.coords(4, 2),
        action = function() GameState.instance.obstacles[2] = {} end,
        undoaction = function() GameState.instance.obstacles[2] = init_obstacle(0,0 , 1,8) end,
      }, {
        active = true,
        position = units.coords(22, 4),
        action = function() GameState.instance.obstacles[8] = init_obstacle(20,1 , 1,7) end,
        undoaction = function() GameState.instance.obstacles[8] = {} end,
      },
    }

    -- enemies
    self.enemies[0] = { active = true, position = units.coords(-4, 4) }

  end

  self.current_level = level
end

function GameState.open_next_level()
  local self = &GameState.instance
  self:open_level(self.current_level + 1)
end

function GameState.lost_level()
  local self = &GameState.instance
  self:open_level(self.current_level)
end

game_functions.lost_level        = GameState.lost_level
game_functions.open_next_level   = GameState.open_next_level
game_functions.get_camera_offset = GameState.get_camera_offset
game_functions.is_intersecting_obstacle = GameState.is_intersecting_obstacle
game_functions.is_intersecting_door     = GameState.is_intersecting_door
game_functions.is_intersecting_switch   = GameState.is_intersecting_switch
game_functions.is_intersecting_player   = GameState.is_intersecting_player
game_functions.is_enemy_seeing_player   = GameState.is_enemy_seeing_player

GameState.instance:open_level(1)

local function update()
  GameState.instance.player:update()
  for i = 0, < #GameState.instance.enemies do GameState.instance.enemies[i]:update() end

  GameState.instance.door:paint()
  for i = 0, < #GameState.instance.obstacles do GameState.instance.obstacles[i]:paint(GameState.get_camera_offset()) end
  for i = 0, < #GameState.instance.switches do GameState.instance.switches[i]:paint() end
  for i = 0, < #GameState.instance.enemies do GameState.instance.enemies[i]:paint() end

  GameState.instance.player:paint()
end

setup_wasm4_callbacks!(update)

